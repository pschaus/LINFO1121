.. _part5_1:

.. rubric:: Partie 5 | Files de priorités, union-find et compression de données

*************************************************************************************************
Partie 5: Questions d'introduction
*************************************************************************************************

Objectifs
=========

À l'issue de cette partie, chaque étudiant sera capable de:

* de décrire avec exactitude et précision les concepts présentés dans le livre de référence et qui traitent de *structures union-find*,  *files de priorité* et  de manipulation/compression de données textuelles,
* de *mettre en oeuvre* un algorithme de compression de texte basé sur un codage de Huffman,
* *évaluer* et *mettre en oeuvre* une représentation efficace  d'une file de priorité sur base d'un *tas* (Heap, en anglais),
* de *concevoir* et *implémenter* un programme de compression/décompression de texte.

Calendrier
==========

TODO


A lire
=======================================

Livre de référence:

* chapitre 1.5 (union find), 2.4 (heap), 5.5 (Huffman compression).


Exercices théoriques
=======================================

.. note::
   Vous devez faire ces exercices pour le mercredi de S9.

Exercice 5.1.1
""""""""""""""

Donnez le tableau ``id[]`` qui résulte de la séquence suivante de 6 opérations d'union sur un ensemble de départ de 10 items avec l'algorithme quick-find.
``3-8, 1-7, 1-8, 9-4, 6-4, 2-0``.
Votre réponse doit être une séquence de 10 entiers.
Rappel: la convention quick-find pour l'union ``p-q`` est de changer ``id[p]`` (et éventuellement d'autres entrées) mais pas ``id[q]``.

.. answer::

    ``0 8 0 8 4 5 4 8 8 4``

Exercice 5.1.2
""""""""""""""

Donnez le tableau id[] qui résulte de la séquence suivante de 9 opérations d'union sur un ensemble de 10 items en utilisant l'algorithme weighted quick-union:

``4-6, 3-6, 8-9, 7-0, 1-2, 8-4, 6-5, 1-7, 6-0.``

Votre réponse doit être une séquence de 10 entiers. Rappel: Lors de la fusion de deux arbres de même taille, l'algorithme weighted quick-union utilise la convention
de faire pointer la racine du second arbre vers la racine du premier arbre.
Notre algorithme utilise l'union par la taille (nombre de noeuds) et pas l'union par la hauteur, ni la technique de compression de chemin.

.. answer::

    7 4 1 4 4 4 4 1 4 8

Exercice 5.1.3
""""""""""""""

Le(s)quel(s) tableau(x) id[] suivant(s) pourrai(en)t résulter de l'application de l'algorithme weighted quick-union sur un ensemble de 10 items au départ?
Rappel: nous utilisons l'union par la taille (nombre de noeuds) et pas l'union par la hauteur.

* ``0 8 2 3 4 7 6 8 8 9``
* ``4 2 6 6 2 6 6 2 4 2``
* ``7 0 0 0 0 1 0 5 1 0``
* ``3 3 0 3 0 3 3 3 5 2``
* ``1 3 3 6 4 1 6 0 6 8``

.. answer::

    * correct
    * ko Size of tree rooted at parent of 2 < twice the size of tree rooted at 2
    * ko
    * correct: sequence ``0-4 3-1 5-8 3-6 5-6 2-9 0-2 9-8 5-7``
    * ko Height of forest :math:`= 4 > \log N = \log(10)`

Exercice 5.1.4
""""""""""""""

Donnez la séquence des clefs dans le tableau qui résulte de l'insertion de la séquence des 3 clefs 48, 30 et 84
dans la heap suivante (orientée vers le maximum) de taille 10:

``97 , 93 , 89 , 83 , 38 , 32 , 40 , 12 , 26 , 24``.

Votre réponse devrait être une séquence de 13 entiers.

.. answer::

    The correct answer is: 97 93 89 83 48 84 40 12 26 24 38 30 32
    Here is the sequence of keys in the array after each insertion:

    ========  ==========================================
    start     ``97 93 89 83 38 32 40 12 26 24``
    after 48  ``97 93 89 83 48 32 40 12 26 24 38``
    after 30  ``97 93 89 83 48 32 40 12 26 24 38 30``
    after 84  ``97 93 89 83 48 84 40 12 26 24 38 30 32``
    ========  ==========================================

Exercice 5.1.5
""""""""""""""

Donnez la séquence des clefs dans le tableau qui résulte de l'ajout de 3 opérations successives de suppression du maximum dans la heap suivante (orientée vers le maximum)
de taille 10:

``98 , 96 , 84 , 34 , 62 , 31 , 72 , 13 , 27 , 33``.

Votre réponse devrait être une séquence de 7 entiers.

.. answer::

    The correct answer is: 72 62 31 34 33 13 27
    Here is the sequence of keys in the array after each deletion:

    ==========  ========================================
    start       ``98 96 84 34 62 31 72 13 27 33``
    98 deleted  ``96 62 84 34 33 31 72 13 27``
    96 deleted  ``84 62 72 34 33 31 27 13``
    84 deleted  ``72 62 31 34 33 13 27``
    ==========  ========================================

Exercice 5.1.6
""""""""""""""""

Quels sont les avantages et inconvénients éventuels d'implémenter une file de
priorité par un heap plutôt que par une liste ?

.. answer::

    On en profite pour rappeler qu'on peut implémenter des ADT (ici une PQ) par plusieurs manières
    (ici, une heap, ou une liste, ou ...) et toutes ne se valent pas.

    Une implémentation par une liste maintenant simplement l'ordre est en :math:`\mathcal{O}(n)` en insertion,
    mais :math:`\mathcal{O}(1)` en deletion. Au contraire du :math:`\mathcal{O}(\log n)` offert par les deux opérations
    d'une heap.

    Existe-t-il des cas où une implémentation basée sur une liste est utile?
    Probablement pas; on veut souvent retirer tout les élements qu'on insére dans une PQ.

Exercice 5.1.7
""""""""""""""

Existe-t-il un tas T mémorisant 7 éléments distincts tel qu'un parcours
infixe du tas renvoie les éléments de T en ordre décroissant ?
Qu'en est-il avec un parcours préfixe ou post-fixe ?

.. answer::

    Soit le heap suivant:

    .. image:: heap7.png

    Les ordres sont les suivants:

    * infixe: :math:`D<B<E<A<F<C<G`
    * préfixe: :math:`A<B<D<E<C<F<G`
    * postfixe: :math:`D<E<B<F<G<C<A`

    La propriété de min-heap implique que :math:`A < B, A < C, B < D, \ldots`.

    Le postfixe est donc le seul qui fonctionne (il y des contradictions dans les autres cas).
    Avec un max-heap, vous avez seulement le préfixe qui fonctionne.


Exercice 5.1.8
""""""""""""""

Quelles déclarations suivantes sont vraies à propos d'une file de priorité implémentée par une heap? Par défaut les heaps sont orientées maximum et utilisent une base d'indice commençant à 1.

* Dans le pire cas, l'insertion d'une clef dans une heap binaire contenant N clefs nécessite :math:`\sim \log N` comparaisons.

  .. answer::

    true: each swim operation compares the inserted key only to keys on a path from the new leaf to the root

* Soit :math:`a[]` un tableau tel que :math:`a[1] > a[2] > \ldots > a[N]` (et :math:`a[0]` est vide). Alors :math:`a[]` satisfait les propriétés d'une heap binaire.

  .. answer::

    true: A reverse-sorted array obeys heap order.

* Le tableau d'une (max-)heap binaire est toujours un tableau trié dans l'ordre décroissant.

  .. answer::

    faux. [-,3,1,2] est correct et n'est pas décroissant.

* Étant donné une heap binaire de N clefs distinctes, supprimer la clef maximum et ensuite l'insérer directement laisse le tableau de la heap inchangé (on ignore les redimensionnements possibles du tableau) .

  .. answer::

    False, Consider the binary heap Key[] = [ -, 3, 2, 1 ]. After the deletion of max key, it will be [ -, 2, 1 ]. After the insertion, it will be [ -, 3, 1, 2 ].

Exercice 5.1.9
""""""""""""""

Exercise 2.4.20 Prouver que la construction bottom-up "sink" d'une heap pour le Heapsort (p323) se fait en :math:`\mathcal{O}(n)`.
Indice: comptez le nombre de noeuds au niveau :math:`h` de la heap.
Quelle est la complexité d'un sink à ce niveau. Faites la somme pour tous les niveaux. Formule utile: :math:`\sum_{k=0}^\infty k x^k = x/(1-x)^2` pour
:math:`|x| < 1`.

.. answer::

    from the bottom, at level :math:`j` there are :math:`2^{h−j}` nodes, and each might shift down :math:`j` levels. So, if we count from bottom to top, level-by-level, we see that the total time is proportional to

    .. math::

        T(N) = \sum_{j=0}^h j \frac{2^h}{2^j} = 2^h \sum_{j=0}^h  \frac{j}{2^j}  \le 2^h \sum_{j=0}^{+\infty}  \frac{j}{2^j} \le 2^h \cdot 2 = 2^{\log n} = n

Exercice 5.1.10
""""""""""""""""

L'utilisation d'une file de priorité est-elle indispensable
pour pouvoir construire un code de Huffman ? Pouvez-vous imaginer
une autre solution en utilisant un algorithme de tri ? Sa complexité calculatoire serait-elle meilleure que l'algorithme original ? Pourquoi ?

.. answer::

    Oui indispensable. Un insertion sort coûterait du :math:`\mathcal{O}(n)` à chaque fois donc ça serait du :math:`\mathcal{O}(n^2)` pour construire le tree au départ du tableau des fréquences.

Exercice 5.1.11
""""""""""""""""

* Quelles sont les différentes étapes d'un algorithme de compression de texte qui prend en entrée un texte et fournit en sortie une version comprimée de ce texte à l'aide d'un codage de Huffman ? Soyez précis dans votre description en isolant chaque étape du problème. Précisez notamment pour chaque étape les structures de données utiles et la complexité temporelle des opérations menées.
* Quelles sont les différentes étapes d'un algorithme de décompression de texte qui prend en entrée une version comprimée d'un texte à l'aide d'un codage de Huffman et fournit en sortie le texte original ? Soyez précis dans votre description en isolant chaque étape du problème. Précisez notamment pour chaque étape les structures de données utiles et la complexité temporelle des opérations menées.

.. answer::

    bullet point p835.

Exercices d'implémentation sur INGInious
==========================================

.. note::
   Vous devez faire ces exercices pour le mercredi de S10.


1. `Exercices sur les heap <https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part5Heap>`_
2. `Exercices sur le UnionFind <https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part5UnionFind>`_
3. `Implem Huffman <https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part5Huffman>`_
4. `Implem UnionFind appliqué <https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part5GlobalWarming>`_
5. `Implem Heap push <https://inginious.info.ucl.ac.be/course/LSINF1121-2016/PART5BinaryHeapPush>`_
