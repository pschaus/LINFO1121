.. _part5_2:

.. rubric:: Partie 5 | Files de priorités, union-find et compression de données

*************************************************************************************************
Partie 5: Questions supplémentaires
*************************************************************************************************

Exercice 5.2.1
""""""""""""""
Dans la technique de compression par un codage de Huffman, il s'avère utile
d'inclure dans le fichier comprimé une entête contenant l'information nécessaire au décodage
de ce fichier. Dans votre implémentation, l'entête est probablement une version sérialisée
de l'arbre (résultat d'un parcourt préfixe) tel que proposé dans le livre.
Pensez-vous qu'il serait plus ou moins intéressant d'un point de vue mémoire de stoker pour chaque symbole, son codage binaire
plutôt que l'arbre sérialisé ?

Exercice 5.2.2
""""""""""""""

Peut-on gagner encore en taux de compression si l'on réapplique
l'algorithme de compression de Huffman sur un fichier déjà comprimé une première fois ?
Que se passe-t-il dans ce cas ?
Cela ouvre-t-il la porte vers un algorithme de compression récursif et optimal ?

.. answer::

    Huffman is able to compress better when the number of symbols is not large (less than the whole asci set) and/or when they are large differences in the number of occurences.
    It works well for text input because this is exactly what we have in natural languages.
    After a first compression, you loose this nice property of natural languages because the input does not correspond to a text anymore.
    Also you need to consider the preorder encoding table as an input). Conclusion: no guarentee it will be usefull because it is not a natural language, the counters should be much more uniform and also you need to add again a new encoding table (preorder traversal of the tree).

Exercice 5.2.3
""""""""""""""

Quel est, approximativement, le taux de compression obtenu si l'on applique l'algorithme
de compression de Huffman sur un un fichier comportant une seule chaîne composée du caractère 'a' répété un million (:math:`\approx 2^{20}`) de fois, suivi du caractère ``b`` présent une seule fois ?
Le taux de compression obtenu varie-t-il avec la longueur du fichier  (par exemple, si le caractère ``a`` est répété deux millions de fois) ?
A votre avis, quel est le nombre minimal de bits nécessaires pour représenter sous forme comprimée  ce fichier ?
Peut-on adapter la technique de compression par un codage de Huffman en mesurant
la fréquence d'autre chose que les caractères présents ? Peut-on utiliser une autre technique
de compression qui serait plus efficace dans ce cas particulier ?

.. answer::

    Assume the file is encoded in extended ASCI (256 symbols) thus one byte required for each letter.
    The prefix in the encoding is negligible given the size of the text. The compression rate is thus 1/8 (since huffman will need 0 and 1 for encoding 'a' 'b').
    This compression rate would not change whatever the number of 'a' followed buy a 'b'.
    If we know that the form of the file is given by the regular expression :math:`[a*b]`, then only one number is needed for the number of 'a'. Thus one int.

    Yes, Huffman can count anything with the form of fixed size number of bits (colors for images, etc).

    Yep, another technique could be "character" followed by the number of consecutive occurences". For instance "aaabbbbbbbccaaa" would become "a3b7c2a3".

Exercice 5.2.4
""""""""""""""

Imaginez une implémentation d'une file de priorité par un tas (heap, en anglais) à l'aide d'une structure chaînée pour représenter l'arbre binaire essentiellement complet correspondant au tas.
Combien de liens sont nécessaires dans chaque noeud ?
Écrivez le code des méthodes *insert*, *delMax*. Quelle en est la complexité ? Est-il utile de donner la taille *max N* dans le constructeur ?
Comment faites-vous pour ajouter un nouveau noeuds dans la heap ou retirer le prochain noeud ? Est-ce que cela peut être fait au départ de la taille courante de la heap ?

.. answer::

    You need to have access to the parent and the two children for each node => 3 links/node.
    No you don't need a "maxN" value but you need to be able to add a new node on the last layer or remove the last one of the last layer efficiently. This can be done using the current size :math:`n` in :math:`O(log(n))`.
    The hight :math:`h = \lfloor log_2 (n+1) \rfloor`. The node index of the last node on the last layer is :math:`n-(2^h-1)`. You can consider this node index as a binary number. Each bit tells you if you should follow the left/right link from the root down to the leaf you are looking for in the tree (to retrieve where to add or delete the node at the last layer).

Exercice 5.2.5
""""""""""""""

Proposez une structure de données qui supporterait les opérations suivantes en temps logarithmique: *insertion*, *supprimer le maximum*, *supprimer le minimum*;
et les opérations suivantes en temps constant: *trouver le maximum et le minimum*.
Pour cela, nous vous proposons d'étudier la propriété suivante appelée min-max heap.
Les niveaux pairs sont: 0 (racine), 2, 4, etc.
Ces niveaux pairs sont aussi appelés les niveau :math:`min`.
Les niveaux impairs sont 1, 3, 5, etc.
Les niveaux impairs sont aussi appelés les niveaux :math:`max`.
Pour n'importe quel élément :math:`x` dans la min-max heap on a la propriété suivante:

*  Si :math:`x` est à un niveau  :math:`min`, tous les descendants de :math:`x` sont supérieurs à :math:`x`.
*  Si :math:`x` est à un niveau :math:`max`, tous les descendants de :math:`x` sont inférieurs à :math:`x`.


Questions:

* D'après cette propriété déterminez quel est le plus petit élement de la heap ?

  .. answer::

    c'est celui de la racine.

* Quel est le plus grand élément de la heap ?

  .. answer::

    Le maximum entre les deux éléments du niveau 1

* Dessinez une min-max heap qui contient les éléments suivants: 10,8,71,31,41,46,51,31,21,11,16,13.

  .. answer::

    .. image:: minmaxheap.png

* Décrivez l'opération d'insertion dans une min-max heap? Donnez le pseudo-code.

  .. answer::

    Attention, il faut aller voir au niveau :math:`i-2` pour voir s'il ne faut pas swapper.

Exercice 5.2.6
""""""""""""""

Imaginez une structure de données qui supporte

1. l'*insertion* en temps logarithmique
2. l'opération *trouver la médiane* en temps constant
3. *supprimer la médiane* en temps logarithmique.

.. answer::

    Il faut utiliser deux heap, chacune contenant la moitié des éléments.
    La première heap est une max-heap et contient les :math:`n/2` plus petits éléments.
    La deuxième heap est une min-heap et contient les :math:`n/2` plus grands éléments.
    Assez facile de maintenir cette propriété lors de l'insertion d'un élément et le retrait de la médiane.