.. _part2_2:

.. rubric:: Partie 2 | Tri et propriétés des ensembles triés

*************************************************************************************************
Partie 2: Questions supplémentaires
*************************************************************************************************

Exercice 2.2.1
"""""""""""""""

Écrivez une méthode qui prend en entrée un tableau d'intervalles et qui retourne l'union de ces intervalles comme un tableau d'intervalles disjoints. On considère que les intervalles d'input sont donnés sous la forme de deux tableaux `int[] min, int[] max;` où le ième intervalle est donné par ``(min[i],max[i])``. Exemple d'entrée ``min=[5,0,1,6,2]`` ``max=[7,2,2,8,3]`` donnerait en sortie ``min=[0,5],max=[3,8]``.
Ecrivez le pseudo-code. Quelle est la complexité de votre méthode ?

.. answer::

    This problem can be elegantly solved
    with a sweep-line approach algorithm.
    Create a sequence composed of (a,b) couples:
    ``S=(min[0],+1),(max[0]+1,-1),...,(min[n-1],+1),(max[n-1]+1,-1),(+inf,0)``.
    Sort the sequence lexicographically:

    - increasingly in 'a',
    - decreasingly in 'b'

    Then use this code:

    .. code-block::

        int start = S[0].min
        overlap = S[0].b // always +1
        union = {}
        int i = 1
        while (i < 2n) {
          overlap += S[i].b
          if (overlap == 0) {
            // closed interval
            union.append([start..S[i].a])
            start = S[i+1].a // fine because we have a dummy element at 2n
          }
          i += 1
         }
        }

    Les étudiants ne trouvent généralement pas cet algorithmes (qui est tout de même intéressant de leur montrer).
    Voice l'algorihtme trouvé par les étudiants:

    - trier les intervalles (a,b) sur base du start (a).
    - considèrer chaque intervalle en maintenant la fermeture candidate maximum (b)

    Si on rencontre un start, plus grand que cette fermeture candidate la plus loin, on ferme l'intervalle courant.

Exercice 2.2.2
"""""""""""""""

Vous devez trier un grand tableau qui a pour propriété qu'il ne contient que des valeurs dans l'ensemble ``{0,1,2}``.
Quel algorithme de tri suggérez-vous? Ecrivez le code.
Quelle sera la complexité pour trier le tableau? Discutez cette complexité par rapport à la borne inférieure d'un algorithme de tri (Proposition 1 pages 280-281).

.. answer::

    Il s'agit d'un bucket-sort. Pourquoi est-il en :math:`\mathcal{O}(n)` et pas en :math:`\mathcal{O}(n\log n)`?
    N'y a t'il pas une preuve dans le livre disant que tout tri est en :math:`\mathcal{O}(n\log n)` pourtant?

Exercice 2.2.3
"""""""""""""""

Le mode d'un tableau de nombres est le nombre qui apparait le plus fréquement dans le tableau. Par exemple (4,6,2,4,3,1) a le mode 4. Donnez un algorithme efficace pour calculer le mode d'un tableau de :math:`n` nombres. Quid si on sait que le tableau ne contient que des valeurs de 0 à :math:`k` ?

.. answer::

    Solution1: two steps a) Sort all the elements then 2) find the repeating value with the largest span in the sorted array.
    Solution2 (advanced): You can embed the discovery of the mode in a quick-sort. During the pivoting step, we count the number of elements equal to the pivot value and keep track of the current best candidate mode (and its frequency of cours). This information can be used to avoid some recursive calls: we only process (recursive quick-sort call) a partition if is it larger than the count of the best candidate mode found so far.

    The students wont probably think about this solution but you can give them some hints: Can we cound the frequency of one value during the pivoting ? Can we keep track of the current best mode such that at the end of the quicksort we have the mode and don't need to scan again the sorted elements ? Assume that current best mode is has a count of 10, is it worth searching for a  mode in a partition of size 5 ?

    If we know that the range of values is between 0 to k, we can use a counting array and simply return the index with the max counter.

Exercice 2.2.4
"""""""""""""""

Étant donné deux ensembles :math:`S_1` et :math:`S_2` (chacun de taille :math:`n`), et un nombre :math:`x`. Décrivez un algorithme efficace pour trouver s'il existe une paire :math:`(a,b)` avec :math:`a \in S_1,b \in S_2` telle que :math:`a+b=x`.
Quelle est la complexité de votre algorithme? Quid si les ensembles sont dans des tableaux déjà triés ?

.. answer::

    Sort one of the sets one array (already takes :math:`mathcal{O}(n \log(n))`).
    Then for each value :math:`v` in the first (unsorted) set,
    search for the value :math:`x-v` in the second sorted array using a dichotomic search.
    Again this complexity is :math:`mathcal{O}(n\log(n))`.

    If both array are sorted, we can be a bit smarter.
    Instead of iterating over each element in the first array
    we can also do a dichotomic seach on that one based on the minimum/maximum.
    If for a value :math:`v`, the minimum of the second array plus :math:`v` is :math:`>x`
    then we know that it is not worth considereing values :math:`>v` in the first array.
    This amounts at shrinking the bound of values in the first array.
    This doesn't change the worst-case time complexity
    but can reduce the best-case time complexity to :math:`mathcal{O}(\log(n))`.

Exercice 2.2.5
"""""""""""""""

Même question que la précédente mais pour un seul ensemble. Quid si l'ensemble est dans un tableau déjà triés ?

.. answer::

    If the array is sorted, you can use two pointers :math:`i,j` starting from both extremities the array :math:`i=0,j=n-1`.
    For each position :math:`i`, find :math:`j` such that :math:`a[i]+a[j]\ge v` and :math:`a[i]+a[j-1] < v` then increment :math:`i`.
    Since you can start the search for :math:`j` from its previous position, the complexity is :math:`mathcal{O}(n)`.

Exercice 2.2.6
"""""""""""""""

Donnez un algorithme pour calculer l'union de deux ensembles :math:`A` et :math:`B`. Supposons dans un second temps, que l'ensemble :math:`A` déjà trié a une taille :math:`n` et l'ensemble :math:`B` également trié a une taille :math:`n^2`. Quelle serait la complexité, est-ce que votre algorithme change ?

.. answer::

    Let :math:`m` and :math:`n` be the size of the sets.
    Solution1: Put all the element in a large array then sort it => :math:`mathcal{O}((m+n)log(m+n))`.
    Solution2 (a bit faster): Sort each set separately then collect avoiding dupplicates:  :math:`mathcal{O}(m\log(m)+n\log(n))`.
    For the :math:`n` and :math:`n^2` size.
    For each element of the small one you do a dichotomic search on the large one. The time complexity is thus :math:`n \log(n^2) = 2n \log n`.
    This is better than the opposite which would be :math:`n^2 log(n)`.


Exercice 2.2.7 (optionnelle)
""""""""""""""""""""""""""""

Étant donné une matrice de nombres entiers qui sont triés le long des lignes et des colonnes, comment trouver un nombre donné dans la matrice de manière efficace ?
Indice: Il existe un algorithme en temps :math:`mathcal{O}(n+m)` pour une matrice :math:`n\times m`. Pour cela commencez dans le coin supérieur droit et comparez avec le nombre recherché. Quelles parties de la matrice pouvez-vous élaguer dans votre recherche en fonction du résultat?

.. answer::

    Let :math:`(i,j)` initialized as :math:`(0,m-1)` the current row/column position and :math:`v` the number we are looking for.
    If :math:`T[i,j-1] < v` increment :math:`i` else decrement :math:`j`. Complexity :math:`mathcal{O}(n+m)` since it the worst case
    we go until :math:`i=n,j=0` if the element is not found.