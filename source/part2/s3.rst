.. _part2_1:

.. rubric:: Partie 2 | Tri et propriétés des ensembles triés

*************************************************************************************************
Partie 2: Questions d'introduction
*************************************************************************************************

Objectifs
=========

A l'issue de cette partie chaque étudiant sera capable de:

* décrire avec exactitude et précision les concepts présents
  dans le chapitre du livre de référence traitant des *algorithmes de tri*
* mettre en oeuvre et évaluer des algorithmes de tris classiques,
  connaitre leurs avantages, inconvénients et propriétés.

Calendrier
==========

.. list-table:: Calendrier de remise selon votre jour de TP
    :header-rows: 1

    * - TP Mercredi
      - TP Jeudi
      -
    * - Mercredi 23/09
      - Jeudi 24/09
      - Début de la partie 2.
    * - Lundi 28/09 23h59
      - Mardi 29/09 23h59
      - Soumission du rapport pour les questions d'introduction (en groupe)
    * - Mercredi 30/09
      - Jeudi 01/10
      - Première séance tutorée.
    * - Lundi 05/10 23h59
      - Mardi 06/10 23h59
      - Deadline exercice INGInious (individuel) + mini-projet (groupe)
    * - Mercredi 07/10
      - Jeudi 08/10
      - Seconde séance tutorée. Questions de bilan + début partie 3.

A lire
=======================================

Livre de référence:

* Chapitre 1, section 1: quelques rappels de Java et la programmation en général (partie sur le Binary Search)
* Chapitre 2, section 1: Tris élémentaires
* Chapitre 2, section 2: Tri fusion
* Chapitre 2, section 3: Tri rapide
* Chapitre 2, section 5: Application des tris

Exercices théoriques
====================

.. note::
    Ces exercices sont à préparer en groupe, et à rendre le lundi ou le mardi de S3, en fonction de la date de votre
    TP.

Exercice 2.1.1
""""""""""""""

Etant donné un tableau contenant :math:`n` entiers triés, et un nombre :math:`x` à insérer dans le tableau, pouvez-vous
indiquer un algorithme permettant de trouver la position où insérer :math:`x` tout en gardant le tableau trié?

Quelle est la complexité de cet algorithme?

.. answer::

    Deux méthodes:

    * Soit faire une simple recherche, de gauche à droite, dans le tableau: :math:`\mathcal{O}(n)`.
    * Soit faire une recherche dichotomique: :math:`\mathcal{O}(\log n)`.

    Une métaphore qui marche bien est celle du dictionnaire: "comment faites-vous pour chercher dans un dictionnaire
    papier?"

Exercice 2.1.2
""""""""""""""

Nous considérons le problème très général où l'on a :math:`n` jobs à accomplir pour des clients
et chaque job :math:`j` demande :math:`t_j` secondes pour l'accomplir.
Un seul job peut être effectué à la fois.

L'objectif est de terminer tous les jobs tout en maximisant la satisfaction des clients.
Maximiser la satisfaction des clients revient à construire un planning qui minimise
le temps de complétion moyen des jobs.

Par exemple, si la durée des jobs est de 5,8,3,4 et que l'on effectue les jobs dans cet ordre,
les temps de fin seront de 5,13,16,20 et donc le temps de fin moyen sera de
:math:`\frac{5+13+16+20}{4}=13.5`.

Prouvez (avec une preuve écrite!) que trier les :math:`n` jobs dans l'ordre croissant des :math:`t_j` génère une solution
optimale au problème.

.. answer::
    Par l'absurde. Soit une solution optimale au problème, qui ne respecte pas la propriété ci-dessus.
    Numérotons les éléments de la solution dans leur ordre de terminaison, de 0 à :math:`n-1`.

    La valeur de la solution est donc

    .. math::

        \sum_{i=0}^{n-1} \sum_{j=0}^i t_j

    Il existe :math:`a` tel que :math:`t_a > t_{a+1}`, sinon, la solution serait triée et la propriété respectée.

    Si on inverse :math:`a` et :math:`a+1` dans la solution, on obtient une nouvelle solution de valeur

    .. math::

        (\sum_{i=0}^{a-1} \sum_{j=0}^i t_j) + (\sum_{j=0}^{a-1} t_j + t_{a+1})
        + (\sum_{j=0}^{a-1} t_j + t_{a+1} + t_a) + (\sum_{i=a+2}^{n-1} \sum_{j=0}^i t_j)

    A comparer avec l'ancienne valeur:

    .. math::

        (\sum_{i=0}^{a-1} \sum_{j=0}^i t_j) + (\sum_{j=0}^{a-1} t_j + t_{a})
        + (\sum_{j=0}^{a-1} t_j + t_{a} + t_{a+1}) + (\sum_{i=a+2}^{n-1} \sum_{j=0}^i t_j)

    La différence entre la nouvelle et l'ancienne valeur est

    .. math::

        t_{a+1} + t_{a+1} + t_a - t_a - t_a - t_{a+1} = t_{a+1} - t_{a} < 0

    Autrement dit, la nouvelle solution a un coût plus petite que la précédente, qui n'était donc pas optimale.
    Contradiction.

Exercice 2.1.3
""""""""""""""

Qu'entend-t-on par un algorithme de tri stable et en place (in place)?
Pour tous les algorithmes présentés dans le livre de référence,
indiquez s'ils sont en place (ou pas) ou stable (ou pas).

.. answer::

    Stable: si la clé de tri associée à deux valeurs différentes est la même, ces deux valeurs resteront
    dans le même ordre relatif après tri.

    In-place: n'utilise pas de mémoire supplémentaire. (du moins, pas plus que :math:`\mathcal{O}(1)`).

Exercice 2.1.4
""""""""""""""

Comment trieriez vous un tas de cartes avec la restriction que les
seules opérations permises sont:

1. comparer les deux premières cartes,
2. échanger les deux premières cartes,
3. bouger la première carte à l'arrière du tas?

.. tip::

    Le "Bubble-Sort" est un algorithme de tri qui consiste à comparer de manière
    répétée les éléments consécutifs d'un tableau, et à les permuter lorsqu'ils sont mal
    triés. Cette opération est répétée jusqu'à ce que la liste soit triée.
    Cet algorithme peut éventuellement vous inspirer.

Écrivez le pseudo code de votre algorithme et donnez-en la complexité.

.. answer::

    Apply a bubble sort-like algo.

    .. code-block::

        for (i in 1 to n)
            invariant: the i-1 last ones are sorted
            for (k in 1 to n)
                if (k <= n-i)
                    put the smalest of the two top cards on top
                move the top card at the end


Exercice 2.1.5
""""""""""""""

Comment trier une liste doublement chaînée (qui ne permet donc pas d’accéder
à une position par son indice) efficacement? Quelle est la complexité de votre
algorithme?

.. answer::

    Il y a moyen d'adapter le quick sort ou le merge sort à des listes.
    Notez que la question à l'examen sera peut-être "trier cette liste doublement chainée..."
    et qu'il faudra le coder.

Exercice 2.1.6
""""""""""""""

Imaginez un algorithme efficace pour compter le nombre de paires de valeurs désordonnées.
Par exemple dans la séquence :math:`1,3,2,5,6,4,8` il y a les paires :math:`(3,2),(5,4),(6,4)`
qui sont non ordonnées. Justifiez la complexité de votre algorithme et donnez son pseudo code.

.. tip::

    Supposons deux tableaux :math:`A` et :math:`B`, soit :math:`A.B` le tableau résultat de la
    concaténation de :math:`A` et :math:`B`. Soit :math:`nUnsorted(A)` le nombre de paires désordonnées
    dans un tableau :math:`A`.

    Nous avons la propriété suivante que vous pouvez prouvez:

    .. math::

        nUnsorted(A.B) = nUnsorted(A)+ nUnsorted(B)+|\{(i,j) : A[i]>B[j]\}|


    Quelle est la complexité pour calculer :math:`|\{(i,j) : A[i]>B[j]\}|` ?
    Est-ce que cette complexité peut être améliorée si :math:`A` et :math:`B` sont triés?
    Ne pouvez-vous pas calculer :math:`nUnsorted` sur base d'une variante d'un algorithme de tri bien
    connu qui s'exécute en :math:`\mathcal{O}(n \cdot \log(n))`?

.. answer::

    L'algorithme demandé est en fait basé sur le même principe que le merge sort.

    L'idée est que calculer :math:`|\{(i,j) : A[i]>B[j]\}|` "bètement" est en :math:`\mathcal{O}(n^2)`.
    Remarquez que si on trie A et B, cela ne change pas le résultat.
    Il existe un algorithme en :math:`\mathcal{O}(n)` si A et B sont triés:

    .. code-block:: java

        int wrongOrder(int[] A, int [] B) {
            // A et B sont des tableaux triés dans l'ordre croissant
            int posB = B.length;
            int count = 0;
            for(int i = A.length - 1; i >= 0; i--) {
                while(posB != 0 && B[posB-1] >= A[i])
                    posB--;
                count += posB;
            }
            return count;
        }

    Faite un dessin au tableau avec un exemple de deux tableaux triés et des nombres aléatoires (1, 3, 4, 7 et 2, 5, 6, 8 font le job).
    L'idée est donc de faire un merge-sort. On peux coder la fonction comme suit:

    * Appeler la fonction récursivement sur la première moitié du tableau (cela trie la première moitié et retourn ``nUnsorted(A)``)
    * idem sur la seconde moitié (cela trie + calcule ``nUnsorted(B)``)
    * calculer `wrongOrder(A, B)`
    * effectuer le merge du merge sort, ce qui trie le tableau complet.

Exercice 2.1.7
""""""""""""""

Imaginons que nous souhaitons trier des objets ``Person`` de manière lexicographique par leur (poids, age, taille)
mais aussi des objets ``Student`` par leur (age, note, année), comment faire pour ne pas dupliquer l'algorithme de tri
spécifiquement pour ces classes?

Expliquez pourquoi les notions de ``Comparable`` et ``Comparator`` de Java sont utiles pour cela?
Expliquez comment vous implémenteriez un ``Comparator`` efficace pour des ``String``.

Exercice 2.1.8
""""""""""""""

Est-il possible d'obtenir un tri stable au départ d'un algorithme de tri non stable? Comment?

.. answer::

    On peut englober la valeur à trier dans un objet qui contient sa "position", et faire un tie-break dans
    la fonction de comparaison.

Exercice 2.1.9
""""""""""""""

Comment feriez-vous pour obtenir la 3e plus petite valeur dans un tableau d'un millions de int?
Quelle est la complexité de votre algorithme?

.. answer::

    Les étudiants doivent tomber sur un algorithme linéaire qui maintien les 3 plus petits nombres, de la même manière
    qu'on calcule un minimum.

    Quid de trouver la 5ième plus petite?
    Et la 10ième?
    Et la 100ième?

Exercice 2.1.10
"""""""""""""""

Comment feriez-vous pour obtenir la médiane d'un tableau de valeur (donc la :math:`\frac{n}{2}` ième valeur) ?
Quelle est la complexité de votre algorithme?

.. tip::

    Que pouvez-vous déduire concernant la position de la médiane après l'opération de partitionnement
    autour d'une valeur :math:`v` dans l'algorithme Quick-Sort?

.. answer::

    Clairement, l'algorithme présenté à la question 2.1.9 n'est pas linéaire si la position à trouver est dépendente
    de la taille du tableau, mais quadratique.

    Une solution simple, auquelle les étudiants doivent penser, est de simplement trier le tableau. :math:`\mathcal{O}(n\log n)`.

    L'astuce ci-dessus propose une autre algorithme, qui s'appelle quick-select.
    L'idée est qu'une fois un pivot de quicksort est effectué, le pivot est placé à l'endroit correct.
    Si :math:`n/2` est > que la position du pivot, alors continuer uniquement à droite, sinon uniquement à gauche.

    Comme quick-sort, quick-select est :math:`\Theta(n^2)` dans le pire cas, mais en moyenne, il est en :math:`\mathcal{O}(n)`.

Exercice 2.1.11
"""""""""""""""

Qu'est-ce que le Autoboxing and Unboxing en Java?
En quoi est-ce que cela peut impacter les performances d'un algorithme de tri?

Comparer les performances de ``java.util.Sort`` sur un tableau de 10000000 entrées composé de ``int`` et
le même tableau avec des ``Integer``.

Exercice 2.1.12
"""""""""""""""

Qu'est-ce qu'un *profiler* de code?
Quelles informations fournies par un profiler pourriez-vous utiliser pour améliorer les
performances de votre algorithmes et structures de données de manière générale (vitesse, mémoire, GC)?

Un bon profiler gratuit est VisualVM.

Utilisez VisualVM sur votre code pour la question précédente.

.. tip::

    Même si vous vous repartissez tous les questions, vous devez tous installer visualvm ;-)

.. answer::

    Si les étudiants ont leur ordinateur sur eux, vérifiez qu'ils ont installé visualvm et savent s'en servir.

Exercices sur INGInious
==========================================

.. note::
   Vous devez faire ces exercices pour le lundi ou mardi de S4, individuellement.


1. `Union intervals <https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part2UnionIntervals>`_ (notez le lien avec la question 2.2.1)
2. `Mediane <https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part2Median>`_
3. `Merge Sort <https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part2MergeSort>`_
4. `QCM <https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part2QCM>`_
5. `Global Warming <https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part2GlobalWarming>`_

Mini-projet
===========

.. note::
   Vous devez faire ce projet pour S4, en groupe. Le rapport sera à rendre en même temps que les
   questions sur INGInious (le lundi ou mardi de S4 en fonction de si vous avez le mercredi ou jeudi)

Nous nous intéressons à l'étude des algorithmes de tris suivants: Selection sort, Insertion sort, Shell sort, Merge sort, Quick sort.

Il vous est demandé de faire une analyse comparative (théorique et expérimentale) de ces 5 algorithmes.
En particulier nous souhaitons vérifier si les complexités calculatoires théoriques sont en adéquation avec l'expérimentation.
Pour cela nous allons partir de la classe ``SortCompare`` Chap 2.1 p256 du livre de référence que vous pouvez modifier pour vos besoin.

Dans un premier temps, nous demandons à chaque étudiant du groupe d'implémenter un des algorithmes de tri ci-dessus (ou une variante proposée dans le livre).
Le rapport contiendra des expérimentation sur les performances de ces algorithmes.
Notez que le test ``DoublingTest`` section 1.4 p177 sera utile pour cela et la fonction de plot ``StdDraw`` également.

Dans un second temps, un petit concours interne au sein du groupe visera (sur base d'un protocole à définir dans le groupe) à choisir l'implémentation de l'algorithme de tri la plus efficace.
Nous vous suggérons un peu avant la remise du rapport de faire tourner les tests et de fixer à l'avance les règles du jeu dans votre groupe.
Nous vous demandons également d'inclure dans votre compétition l'algorithme de Java ``Java.util.Arrays.sort(int[])``.
Il est interdit d'utiliser un algorithme ou une variante qui ne serait pas décrite dans le livre.
Le code chaque étudiant doit être sa propre production qu'il comprend parfaitement et non un code copié sur internet.

Amélioration possibles des algorithmes: Insertion Sort: 2.1.25, Shellsort 2.1.29, 2.1.30 p267. Merge sort p275, 3-way or k-way merge p286. Quick Sort: 295-300.

Quelques conseils:

- Se mettre d'accord sur le processus expérimental (donnée de tests, rapport graphiques, etc). Les données d'entrée à trier peuvent être plus ou moins favorable à certains algorithmes.
  Nous vous demandons de tester des séquences aléatoires uniformes, des séquences issues de distribution statistiques, des séquences presque triées, des séquences à nombre limités de nombres possibles.
  Voir par exemple les suggestions 2.1.34 à 2.1.37.
- Les fragments de code extraits du livre de référence peuvent être utilisés.
- Chaque étudiant est responsable de la bonne organisation
  de la mission et de l'équilibre entre son travail personnel et sa participation active au groupe.
