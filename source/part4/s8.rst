.. _part4_2:

.. rubric:: Partie 4 | Dictionnaires: tables de hachages et autres implémentations

*************************************************************************************************
Partie 4: Questions supplémentaires
*************************************************************************************************

Exercice 4.2.1 (Hash des Long and Double)
"""""""""""""""""""""""""""""""""""""""""""""

Voici la formule utilisée par Java pour calculer une fonction de hachage
sur les doubles (bits est un tableau de 64 bit représenté sous forme de long):
``return (int) bits ^ (bits >>> 32)``

* Pourquoi ne pas simplement utiliser ``(int) bits`` (casting de long vers int) ? Indice: Le livre de référence suggère qu'une bonne fonction de hachage doit utiliser tous les bits pour son calcul. Pourquoi ?
* Un double en Java est représenté en 64 bits sous la forme :math:`(-1)^s \times m \times 2^{(e - 1023)}`. Le premier bit :math:`s` est le signe, les 11 bits suivants représentent l'exposant sous forme binaire et les 52 derniers bits représentent la mantisse (partie décimale) sous forme binaire.  Est-ce qu'un nombre décimal positif et son opposé obtiennent des fonctions de hachage différentes ?

.. answer::

   Oui un décimal positif et son opposé n'obtiennent pas les mêmes fonction de hachage. Exemple hashCode(6.0)=1075314688, alors que hashCode(-6L)=-1072168960. Vous pouvez leur dire de tester directement dans Java :-)
   On pourrait penser que le xor suivi du casting ne prenne pas en compte les 32 premiers bits (dont le bit de poids fort).
   Mais grâce (bits ``>>>`` 32), tous les bits auront bien un impact sur la fonction de hachage. Propritété évidemment souhaitable pour éviter les collisions et obtenir une mapping le plus réparti possible sur les int. (il faut que deux double/long "adjacent" (+1, -1, *2, ...) soient "éloignés" les un des autres quand ils sont hashés).

Exercice 4.2.2 (Hash des int castés)
"""""""""""""""""""""""""""""""""""""""""""""


* Est-ce que la fonction de hachage d'un entier sur 32 bits et celle de ce même entier qui serait casté en double sont les mêmes ?

  .. answer::

   Pour le double c'est faux. ((double)5) est représenté comme :math:`(-1)^0\cdot 1.25 \cdot 2^2` c'est à dire:
   0-10000000001-0100000000000000000000000000000000000000000000000000.
   Ce nombre de 64 bit est sans grand rapport avec :math:`0^{61}101`, or la formule est la même. Le hashcode sera donc différent.

* Est-ce que la fonction de hachage d'un entier sur 32 bits et celle de ce même entier qui serait casté en long sont les mêmes ?  Hint: `Long.toBinaryString( Double.doubleToRawLongBits(a))` permet d'afficher le tableau de bits utilisé pour la représentation d'un double.

  .. answer::

   On distingue 2 cas:

   * *cas 1* Si l'entier est positif : **c'est vrai**.
     Le hash d'un entier sur 32 bits est l'entier lui-même.
     Si on caste par exemple l'entier 5 en Long on obtient en représentation binaire :math:`(61x0)101` (il y a juste 32 zeros mis devant).
     La formule de hash sur un long est la même sur sur les doubles. (bits ``>>>`` 32) va donner un masque de 32x0. Le xor va donc laisser l'entier initial intact.
   * *cas.2* si l'entier est négatif: **c'est faux** car pour l'entier  de 32 bits casté en Long aura une représentation différente.
     :math:`5 = (61\times 0)101`, :math:`-5 = (61\times 1) 011 ` en utilisant le complément à 2 de :math:`5`.

Exercice 4.2.3 (Hash de String: le choix de M et R)
""""""""""""""""""""""""""""""""""""""""""""""""""""


La fonction de hachage pour un string donné tel que présenté dans le livre p460 est la suivante:

.. code-block:: java

	int hash = 0;
	for (int i = 0; i < s.length(); i++)
		hash = (R * hash + s.charAt(i)) % M;


Dans l'implémentation du livre, :math:`M` (la taille de la table de hashage) est une puissance de deux.
La valeur suggérée pour :math:`R` est *un petit nombre premier tel que 31 de sorte que les bits de tous les caractères jouent un rôle.*

* Supposons que :math:`R` soit un multiple de :math:`M`. Que se passerait-il lors du calcul ?

  .. answer::

   Supposons par exemple :math:`R=kM` pour un entier :math:`k>0`, on a donc comme indice calculé dans le tableau pour le string :math:`s`:

   .. math::

      \left ( \sum_{i=0}^{n-1} (kM)^{n-i-1}s_i \right ) \% M = \sum_{i=0}^{n-1} \left ((kM)^{n-i-1} s_i \right ) \% M = s_{n-1} \% M.

   C'est vraiment très triste car on voit bien que seul le dernier caractère est pris en compte pour calculer la fonction de hachage. Il faut donc faire très attention à l'interaction entre :math:`M` et :math:`R`.

* Supposons que :math:`R` est un nombre pair. Que se passerait-il ?

  .. answer::

   M s'écrit comme une puissance de deux, disons :math:`2^k`. R est pair, on l'écrit par exemple :math:`2l`. Notre calcul d'indice s'écrit donc comme suit:

   .. math::

      \sum_{i=0}^{n-1} \left ((2l)^{n-i-1} s_i \right ) \% 2^k = s_{n-1} \% M.

   Encore une fois, on voit bien que tous les premiers termes vont donner zero. Plus précisément ceux tels que :math:`n-i-1 \ge k`.

   Donc tous les caractères (et donc tous les bits) ne seront pas pris en compte. Pas bien!

Dans les deux cas, combien d'entrées du string détermineront effectivement le code de hachage ? Quels sont les risques en termes de collision? Est-ce que le contrôle du facteur de charge peut résoudre le problème ? Expliquez pourquoi utiliser 31 est un choix judicieux pour des tailles de tableau qui sont des puissances de deux ? Serait-ce aussi un bon choix pour une taille de tableau qui commencerait à 31 et qui serait multipliée par deux à chaque fois qu'il faut redimensionner ?

* Dans l'implémentation du livre, :math:`M` (la taille de la table de hashage) est une puissance de deux, initialisée à 16. Supposons qu'à moment donné :math:`M` soit :math:`2^8=256`. Ensuite deux clefs entières sont ajoutées dans une table de hachage implémentée avec separate chaining: respectivement :math:`2560` et :math:`3072` (on suppose que ces ajouts ne causent pas de redimensionnement de la table). Comme vous le savez, le code de hachage d'une clef entière (int) est le nombre lui-même.
  Est-ce que l'ajout de ces deux valeurs va causer une collision entre elles dans la table ? Si oui pourquoi ?

  .. answer::

   Oui car dans les deux cas, le :math:`\%256` donne 0.

  Si oui pouvez-vous proposer une troisième valeur qui va aussi entrer en collision ?

  .. answer::

   512

  Si collision il y a, peut-elle disparaître lors du prochain redimensionnement du tableau telle que dans l'implémentation du livre ?

* Que suggérez-vous pour éviter ce problème ? Quelle a la politique d'initialisation de :math:`M` et de redimensionnement utilisée dans ``java.util.HashMap`` ? Est-ce que cela résout le problème sur notre exemple ?

  .. answer::

   Par défaut, le tableau interne dans HashTable est 11. Son redimensionnement garde la taille impaire :math:`(currentSize \times 2+1)`.
   Dans ce cas-ci, on n'a pas de problème. L'avantage de la stratégie de Java est qu'une collision peut disparaître au prochain dimensionnement.
   Alors que pour la stratégie du livre pas nécessairement. En effet, lorsqu'on passe à :math:`M=512`, les deux collisions sont toujours là.

Exercice 4.2.4 (Création de Hash: Véhicules)
"""""""""""""""""""""""""""""""""""""""""""""

* Que suggèreriez-vous comme fonction de hachage pour l'identification de véhicules qui sont des strings de nombres et de lettres de la forme: "9X9XX99X9XX999999" où un 9 représente un chiffre et un "X" une lettre de A à Z.
* Est-ce que votre fonction de hachage a la propriété que pour une taille de tableau N hypothétique de :math:`10^{11} \cdot 26^6` il n'y a jamais de collision?

.. answer::

   Il y a 6 lettres et 11 chiffres.
   Soit :math:`X` la valeur du string des lettres concaténées si on le considère comme un nombre en base 26 (A=0, B=1, ...). La valeur max de ce nombre est :math:`26^6-1`.
   Soit :math:`Y` le nombre obtenu par concaténation des chiffres. La valeur max de ce nombre est :math:`10^{11}-1`.
   Un fonction de hash pour :math:`XY` est :math:`X \cdot 10^{11} + Y`.
   Le maximum de ce nombre est bien :math:`10^{11} \cdot 26^6` et il existe bien une correspondance 1 à 1 (une bijection, donc) entre la fonction de hash et les strings des véhicules.

Exercice 4.2.5 (Création de Hash: Citoyens)
"""""""""""""""""""""""""""""""""""""""""""

Imaginons que l'on cherche à construire un répertoire des citoyens belges
et que l'on veuille pouvoir accéder à chaque citoyen par son numéro de carte d'identité
(12 chiffres).
On peut donc considérer ce numéro comme la clé unique identifiant
chaque citoyen et utiliser cette clé comme l'indice dans un tableau (array en Java).
A chaque indice correspondrait une référence vers une instance de la classe
``Citoyen`` dont les champs constituent les informations que l'on désire mémoriser pour chacun.
Quelle est la complexité temporelle des opérations suivantes ?

* rechercher les informations relatives à un citoyen à partir de son numéro de carte
  d'identité.
* ajouter un nouveau citoyen.

Cette implémentation d'un dictionnaire n'est-elle pas encore meilleure qu'une table de hachage ?
Peut-on avoir un problème de collision dans ce cas ? Justifiez.

.. answer::

   Tout est en :math:`\mathcal{O}(1)`. La magie s'interrompt cependant quand on constate que la taille du dictionnaire
   en mémoire (avec des object ``Citoyen`` de taille :math:`x`) est de :math:`10^12\cdot x`. Avec :math:`x` = 1 ko,
   on obtient 1 Peta-octet de données.

   Il y a 11 millions de citoyen à mettre dans le dico. Le facteur de remplissage serait

   .. math::

      \frac{11\cdot 10^6}{10^12} = 11\cdot 10^{-6}

   Ca ne semble pas être une utilisation très raisonnable de l'espace...

Exercice 4.2.6 Rabin-Karp, le retour de la vengeance
""""""""""""""""""""""""""""""""""""""""""""""""""""

Vérifiez que vous avez bien obtenu une solution en :math:`\mathcal{O}(n)`, et pas :math:`\mathcal{O}(kn)` (en ne comptant
pas le hashing initial des mots-clés à chercher qui est en :math:`\mathcal{O}(km)`),
pour l'exercice 4.1.11 de la semaine dernière.

.. answer::

    La partie :math:`\mathcal{O}(km)` vient du hashing initial des :math:`k` mots-clés de taille :math:`m`, on
    ne peut pas y couper.

    Contrairement, en mettant dans une table de hachage (HashMap ici) les [hash -> mots-clés], on sait savoir en
    O(1) si le hash d'un des mots-clés matche, plutôt que d'aller comparer les hash en :math:`\mathcal{O}(k)`.

    On a donc pour chaque lettre du string principal (de taille :math:`n`) une opération d'update de hash en :math:`\mathcal{O}(1)`
    (update incrémental du hash) suivi d'un check de présence du hash dans la table de hashage en :math:`\mathcal{O}(1)`,
    suivi eventuellement d'un check de collision en :math:`\mathcal{O}(m)` qui peut être négligé.

    On est donc bien en :math:`\mathcal{O}(n)` si on considère qu'il n'y a pas trop de collisions, la même complexité
    qu'avec un seul mot-clé! Magique, non?
