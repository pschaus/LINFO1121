.. _part1_2:

.. rubric:: Partie 1 | Types abstraits de données, Complexité, Collections Java; Piles, files et listes liées

*************************************************************************************************
Partie 1: Questions supplémentaires
*************************************************************************************************

Exercice 1.2.1
==============

La classe ``NodeQueue`` implémente l'interface ``Queue``. On vous demande de
compléter les méthodes de cette implémentation **sans** ajouter ou supprimer
de variables d'instance dans cette classe.
Vous veillerez à **commenter succintement et précisément**
votre code.

.. code-block:: java

    public class Node<E> {
        private E element;
        private Node<E> next;
        public Node(E e, Node<E> n) {
            element = e;
           next = n;
        }
        public E getElement() {return element;}
        public Node<E> getNext() {return next;}
        public void setNext(Node<E> n) {next = n;}
    }

.. code-block:: java

    public class NodeQueue<E> implements Queue<E> {
        // Variables d'instance
        private Node<E> marker;
        private int size;

        // Constructeur
        public NodeQueue() {
            ...................
            ...................
            ...................
            ...................
        }
        public int size() { return size; }
        public boolean isEmpty() { return (size==0); }

        public E front() throws QueueEmptyException {
            ...................
            ...................
            ...................
            ...................
            ...................
            ...................
        }

        public void enqueue (E element) {
            ...................
            ...................
            ...................
            ...................
            ...................
            ...................
            ...................
            ...................
            ...................
            ...................
            ...................
            ...................
            ...................
            ...................
        }

        public E dequeue() throws QueueEmptyException {
            ...................
            ...................
            ...................
            ...................
            ...................
            ...................
            ...................
            ...................
            ...................
            ...................
            ...................
            ...................
            ...................
            ...................
        }
    }

Exercice 1.2.2
==============

L'examen de LINFO1121 comporte une partie programmation des structures de données et algorithmes sur ordinateur.
Pour réussir cette partie, il est indispensable de programmer régulièrement.
Les erreurs triviales de Java seront perçues par le correcteur comme un manque de participation de la part de l'étudiant aux missions de programmation.
Nous vous proposons d'étudier ici quelques erreurs ou problèmes rencontrées fréquemment.

* Nous envisageons d'implémenter une Stack avec un tableau.
  Il faudra donc redimensionner le tableau si la taille de la stack atteint la taille maximale.
  Est-ce que Java dispose d'une méthode efficace pour redimensionner/recopier un tableau?
  Si oui donnez un exemple de code Java pour réaliser cette opération.

  .. answer::

    System.arraycopy

* Est-ce que Java propose une classe pour les ``Stack``, ``Vector``, ``List`` ?
  Si oui dans quel package? A votre avis, est-ce intéressant de bien connaître ce package pour l'examen?
  ``List`` est-elle une interface ou une classe?
  Comment créer un object de type ``List``? Et un objet de type ``Queue``?

  .. answer::

    Most the algorithms covered in this class are available in ``java.util`` (part of standard Java).
    You will spare a lot of time and maximize your chances to succeed if you know well
    ``java.util`` most common classes.
    We have seen at the exam students trying to instantiate object from ``java.util.List``, not understanding
    the differences between interfaces and implementation. The same goes for ``java.util.Queue``...
    Present them the ``ArrayList`` class.

* Quelle est la différence entre un Iterable et un Iterator?

  .. answer::

    An ``Iterable`` is an interface with the method ``iterator()`` producing an iterator.
    An ``Iterable`` is thus a class that can be iterated over (``Vector``, ``Stack``, ``ArrayList``, etc).
    But the real instrument for iteration is the iterator itself (with ``next``, ``hasNext``, etc).
    Any ``Iterable`` object can be used in the for loops with syntactical sugar: ``for (int a: myIterable)``

* Quelle est l'erreur dans le code suivant où l'étudiant cherche à créer un tableau de 5 listes et ensuite insérer l'entier 4 dans la 3e liste? Corrigez le code.

  .. code-block:: java

    List<Integer>[] myList = new List<Integer>[5];
    myList[2].add(4);

  .. answer::

      .. code-block:: java

        List<Integer>[] myList = new List<Integer>[5];
        for(int i = 0; i < myList.length; i++)
            myList[i] = new LinkedList<>();
        myList[2].add(4);

* Quelle est l'erreur dans le code suivant où l'étudiant cherche à créer un objet Iterable? Corrigez le code.

  .. code-block:: java

    Iterable<Integer> myIterable = new Iterable<Integer>();

* Quelle est l'erreur dans le code suivant où l'étudiant cherche à définir un constructeur?

  .. code-block:: java

    public class ADT {
      private int n = 4;
      private ADT myAdt;
      public ADT(int n) {
        n = n;
        myAdt = new ADT(4);
      }
    }

* Quelle est la complexité de ce bout de code, en fonction de la taille de la liste, :math:`n`? Comment l'améliorer?

  .. code-block:: java

    void printList(List<Integer> l) {
        for(int i = 0; i < l.size(); i++) {
            int elem = l.get(i);
            System.out.println(elem);
        }
    }

  .. answer::

    C'est du :math:`\Theta(n^2)` avec certaines implémentations usuelles de listes.

    .. code-block:: java

        void printList(List<Integer> l) {
            for(Integer elem: l) {
                System.out.println(elem);
            }
        }

    ou

    .. code-block:: java

        void printList(List<Integer> l) {
            Iterator<Integer> itr = l.iterator();
            while(itr.hasNext()) {
                int elem = itr.next();
                System.out.println(elem);
            }
        }

Exercice 1.2.3
==============

Pouvez-vous remplir le tableau suivant avec les complexités de chaque opération?
Si une opération n'est pas possible (par exemple, aller au milieu d'une Stack est impossible car non prévu par le TAD,
barrez la case.
Précisez à chaque fois si c'est une complexité amortie ou pas.

.. list-table:: Complexité
   :header-rows: 1

   * - TAD
     - Implémentation
     - Insertion (début)
     - Insertion (fin)
     - Insertion (pos :math:`i`)
     - Supprimer (début)
     - Supprimer (fin)
     - Supprimer (pos :math:`i`)
     - Voir (début)
     - Voir (fin)
     - Voir (pos :math:`i`)
   * - Stack
     - Liste chainée
     -
     -
     -
     -
     -
     -
     -
     -
     -
   * - Queue
     - Liste chainée
     -
     -
     -
     -
     -
     -
     -
     -
     -
   * - Stack
     - Tab. redim.
     -
     -
     -
     -
     -
     -
     -
     -
     -
   * - Queue
     - Tab. redim.
     -
     -
     -
     -
     -
     -
     -
     -
     -
   * - Liste
     - Simpl. Chainée
     -
     -
     -
     -
     -
     -
     -
     -
     -
   * - Liste
     - Doub. Chainée
     -
     -
     -
     -
     -
     -
     -
     -
     -
   * - Liste
     - Tab. redim.
     -
     -
     -
     -
     -
     -
     -
     -
     -

.. answer::

    .. list-table:: Complexité
       :header-rows: 1

       * - TAD
         - Implémentation
         - Insertion (début)
         - Insertion (fin)
         - Insertion (pos :math:`i`)
         - Supprimer (début)
         - Supprimer (fin)
         - Supprimer (pos :math:`i`)
         - Voir (début)
         - Voir (fin)
         - Voir (pos :math:`i`)
       * - Stack
         - Liste chainée
         - /
         - :math:`\Theta(1)`
         - /
         - /
         - :math:`\Theta(1)`
         - /
         - /
         - :math:`\Theta(1)`
         - /
       * - Queue
         - Liste chainée
         - /
         - :math:`\Theta(1)`
         - /
         - :math:`\Theta(1)`
         - /
         - /
         - :math:`\Theta(1)`
         - /
         - /
       * - Stack
         - Tab. redim.
         - /
         - :math:`\Theta(1)` a
         - /
         - /
         - :math:`\Theta(1)` a
         - /
         - /
         - :math:`\Theta(1)`
         - /
       * - Queue
         - Tab. redim.
         - /
         - :math:`\Theta(1)` a
         - /
         - :math:`\Theta(1)` a
         - /
         - /
         - :math:`\Theta(1)`
         - /
         - /
       * - Liste
         - Simpl. Chainée
         - :math:`\Theta(1)`
         - :math:`\Theta(n)`
         - :math:`\Theta(i)`
         - :math:`\Theta(1)`
         - :math:`\Theta(n)`
         - :math:`\Theta(i)`
         - :math:`\Theta(1)`
         - :math:`\Theta(n)`
         - :math:`\Theta(i)`
       * - Liste
         - Doub. Chainée
         - :math:`\Theta(1)`
         - :math:`\Theta(1)`
         - :math:`\Theta(i)`
         - :math:`\Theta(1)`
         - :math:`\Theta(1)`
         - :math:`\Theta(i)`
         - :math:`\Theta(1)`
         - :math:`\Theta(1)`
         - :math:`\Theta(i)`
       * - Liste
         - Tab. redim.
         - :math:`\Theta(n)`
         - :math:`\Theta(1)` a
         - :math:`\Theta(n)`
         - :math:`\Theta(n)`
         - :math:`\Theta(1)` a
         - :math:`\Theta(n)`
         - :math:`\Theta(1)`
         - :math:`\Theta(1)`
         - :math:`\Theta(1)`
