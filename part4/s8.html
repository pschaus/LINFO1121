

<!DOCTYPE html>

<html lang="fr">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Partie 4: Questions supplémentaires &#8212; Documentation LINFO1121 2023-2024</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/translations.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Recherche" href="../search.html" />
 

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Index général"
             accesskey="I">index</a></li>
        <li class="nav-item nav-item-0"><a href="../index.html">Documentation LINFO1121 2023-2024</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Partie 4: Questions supplémentaires</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <p class="rubric" id="part4-2">Partie 4 | Dictionnaires: tables de hachages et autres implémentations</p>
<div class="section" id="partie-4-questions-supplementaires">
<h1>Partie 4: Questions supplémentaires<a class="headerlink" href="#partie-4-questions-supplementaires" title="Lien permanent vers ce titre">¶</a></h1>
<div class="section" id="exercice-4-2-1-hash-des-long-and-double">
<h2>Exercice 4.2.1 (Hash des Long and Double)<a class="headerlink" href="#exercice-4-2-1-hash-des-long-and-double" title="Lien permanent vers ce titre">¶</a></h2>
<p>Voici la formule utilisée par Java pour calculer une fonction de hachage
sur les doubles (bits est un tableau de 64 bit représenté sous forme de long):
<code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">(int)</span> <span class="pre">bits</span> <span class="pre">^</span> <span class="pre">(bits</span> <span class="pre">&gt;&gt;&gt;</span> <span class="pre">32)</span></code></p>
<ul class="simple">
<li><p>Pourquoi ne pas simplement utiliser <code class="docutils literal notranslate"><span class="pre">(int)</span> <span class="pre">bits</span></code> (casting de long vers int) ? Indice: Le livre de référence suggère qu’une bonne fonction de hachage doit utiliser tous les bits pour son calcul. Pourquoi ?</p></li>
<li><p>Un double en Java est représenté en 64 bits sous la forme <span class="math notranslate nohighlight">\((-1)^s \times 1,m \times 2^{(e - 1023)}\)</span>. Le premier bit <span class="math notranslate nohighlight">\(s\)</span> est le signe, les 11 bits suivants représentent l’exposant sous forme binaire et les 52 derniers bits représentent la mantisse (partie décimale) sous forme binaire.  Est-ce qu’un nombre décimal positif et son opposé obtiennent des fonctions de hachage différentes ?</p></li>
</ul>
</div>
<div class="section" id="exercice-4-2-2-hash-des-int-castes">
<h2>Exercice 4.2.2 (Hash des int castés)<a class="headerlink" href="#exercice-4-2-2-hash-des-int-castes" title="Lien permanent vers ce titre">¶</a></h2>
<ul class="simple">
<li><p>Est-ce que la fonction de hachage d’un entier sur 32 bits et celle de ce même entier qui serait casté en double sont les mêmes ?</p></li>
<li><p>Est-ce que la fonction de hachage d’un entier sur 32 bits et celle de ce même entier qui serait casté en long sont les mêmes ?  Hint: <cite>Long.toBinaryString( Double.doubleToRawLongBits(a))</cite> permet d’afficher le tableau de bits utilisé pour la représentation d’un double.</p></li>
</ul>
</div>
<div class="section" id="exercice-4-2-3-hash-de-string-le-choix-de-m-et-r">
<h2>Exercice 4.2.3 (Hash de String: le choix de M et R)<a class="headerlink" href="#exercice-4-2-3-hash-de-string-le-choix-de-m-et-r" title="Lien permanent vers ce titre">¶</a></h2>
<p>La fonction de hachage pour un string donné tel que présenté dans le livre p460 est la suivante:</p>
<div class="highlight-java notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="na">length</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">hash</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span> <span class="o">*</span> <span class="n">hash</span> <span class="o">+</span> <span class="n">s</span><span class="p">.</span><span class="na">charAt</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">%</span> <span class="n">M</span><span class="p">;</span>
</pre></div>
</div>
<p>Dans l’implémentation du livre, <span class="math notranslate nohighlight">\(M\)</span> (la taille de la table de hashage) est une puissance de deux.
La valeur suggérée pour <span class="math notranslate nohighlight">\(R\)</span> est <em>un petit nombre premier tel que 31 de sorte que les bits de tous les caractères jouent un rôle.</em></p>
<ul class="simple">
<li><p>Supposons que <span class="math notranslate nohighlight">\(R\)</span> soit un multiple de <span class="math notranslate nohighlight">\(M\)</span>. Que se passerait-il lors du calcul ?</p></li>
<li><p>Supposons que <span class="math notranslate nohighlight">\(R\)</span> est un nombre pair. Que se passerait-il ?</p></li>
</ul>
<p>Dans les deux cas, combien d’entrées du string détermineront effectivement le code de hachage ? Quels sont les risques en termes de collision? Est-ce que le contrôle du facteur de charge peut résoudre le problème ? Expliquez pourquoi utiliser 31 est un choix judicieux pour des tailles de tableau qui sont des puissances de deux ? Serait-ce aussi un bon choix pour une taille de tableau qui commencerait à 31 et qui serait multipliée par deux à chaque fois qu’il faut redimensionner ?</p>
<ul>
<li><p>Dans l’implémentation du livre, <span class="math notranslate nohighlight">\(M\)</span> (la taille de la table de hashage) est une puissance de deux, initialisée à 16. Supposons qu’à moment donné <span class="math notranslate nohighlight">\(M\)</span> soit <span class="math notranslate nohighlight">\(2^8=256\)</span>. Ensuite deux clefs entières sont ajoutées dans une table de hachage implémentée avec separate chaining: respectivement <span class="math notranslate nohighlight">\(2560\)</span> et <span class="math notranslate nohighlight">\(3072\)</span> (on suppose que ces ajouts ne causent pas de redimensionnement de la table). Comme vous le savez, le code de hachage d’une clef entière (int) est le nombre lui-même.
Est-ce que l’ajout de ces deux valeurs va causer une collision entre elles dans la table ? Si oui pourquoi ?</p>
<p>Si oui pouvez-vous proposer une troisième valeur qui va aussi entrer en collision ?</p>
<p>Si collision il y a, peut-elle disparaître lors du prochain redimensionnement du tableau telle que dans l’implémentation du livre ?</p>
</li>
<li><p>Que suggérez-vous pour éviter ce problème ? Quelle a la politique d’initialisation de <span class="math notranslate nohighlight">\(M\)</span> et de redimensionnement utilisée dans <code class="docutils literal notranslate"><span class="pre">java.util.HashMap</span></code> ? Est-ce que cela résout le problème sur notre exemple ?</p></li>
</ul>
</div>
<div class="section" id="exercice-4-2-4-creation-de-hash-vehicules">
<h2>Exercice 4.2.4 (Création de Hash: Véhicules)<a class="headerlink" href="#exercice-4-2-4-creation-de-hash-vehicules" title="Lien permanent vers ce titre">¶</a></h2>
<ul class="simple">
<li><p>Que suggèreriez-vous comme fonction de hachage pour l’identification de véhicules qui sont des strings de nombres et de lettres de la forme: « 9X9XX99X9XX999999 » où un 9 représente un chiffre et un « X » une lettre de A à Z.</p></li>
<li><p>Est-ce que votre fonction de hachage a la propriété que pour une taille de tableau N hypothétique de <span class="math notranslate nohighlight">\(10^{11} \cdot 26^6\)</span> il n’y a jamais de collision?</p></li>
</ul>
</div>
<div class="section" id="exercice-4-2-5-creation-de-hash-citoyens">
<h2>Exercice 4.2.5 (Création de Hash: Citoyens)<a class="headerlink" href="#exercice-4-2-5-creation-de-hash-citoyens" title="Lien permanent vers ce titre">¶</a></h2>
<p>Imaginons que l’on cherche à construire un répertoire des citoyens belges
et que l’on veuille pouvoir accéder à chaque citoyen par son numéro de carte d’identité
(12 chiffres).
On peut donc considérer ce numéro comme la clé unique identifiant
chaque citoyen et utiliser cette clé comme l’indice dans un tableau (array en Java).
A chaque indice correspondrait une référence vers une instance de la classe
<code class="docutils literal notranslate"><span class="pre">Citoyen</span></code> dont les champs constituent les informations que l’on désire mémoriser pour chacun.
Quelle est la complexité temporelle des opérations suivantes ?</p>
<ul class="simple">
<li><p>rechercher les informations relatives à un citoyen à partir de son numéro de carte
d’identité.</p></li>
<li><p>ajouter un nouveau citoyen.</p></li>
</ul>
<p>Cette implémentation d’un dictionnaire n’est-elle pas encore meilleure qu’une table de hachage ?
Peut-on avoir un problème de collision dans ce cas ? Justifiez.</p>
</div>
<div class="section" id="exercice-4-2-6-rabin-karp-le-retour-de-la-vengeance">
<h2>Exercice 4.2.6 Rabin-Karp, le retour de la vengeance<a class="headerlink" href="#exercice-4-2-6-rabin-karp-le-retour-de-la-vengeance" title="Lien permanent vers ce titre">¶</a></h2>
<p>Vérifiez que vous avez bien obtenu une solution en <span class="math notranslate nohighlight">\(\mathcal{O}(n)\)</span>, et pas <span class="math notranslate nohighlight">\(\mathcal{O}(kn)\)</span> (en ne comptant
pas le hashing initial des mots-clés à chercher qui est en <span class="math notranslate nohighlight">\(\mathcal{O}(km)\)</span>),
pour l’exercice 4.1.11 de la semaine dernière.</p>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table des matières</a></h3>
  <ul>
<li><a class="reference internal" href="#">Partie 4: Questions supplémentaires</a><ul>
<li><a class="reference internal" href="#exercice-4-2-1-hash-des-long-and-double">Exercice 4.2.1 (Hash des Long and Double)</a></li>
<li><a class="reference internal" href="#exercice-4-2-2-hash-des-int-castes">Exercice 4.2.2 (Hash des int castés)</a></li>
<li><a class="reference internal" href="#exercice-4-2-3-hash-de-string-le-choix-de-m-et-r">Exercice 4.2.3 (Hash de String: le choix de M et R)</a></li>
<li><a class="reference internal" href="#exercice-4-2-4-creation-de-hash-vehicules">Exercice 4.2.4 (Création de Hash: Véhicules)</a></li>
<li><a class="reference internal" href="#exercice-4-2-5-creation-de-hash-citoyens">Exercice 4.2.5 (Création de Hash: Citoyens)</a></li>
<li><a class="reference internal" href="#exercice-4-2-6-rabin-karp-le-retour-de-la-vengeance">Exercice 4.2.6 Rabin-Karp, le retour de la vengeance</a></li>
</ul>
</li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Recherche rapide</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Index général"
             >index</a></li>
        <li class="nav-item nav-item-0"><a href="../index.html">Documentation LINFO1121 2023-2024</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Partie 4: Questions supplémentaires</a></li> 
      </ul>
    </div>

    <div class="footer" role="contentinfo">
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.3.1.
    </div>
<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
    <img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" />
</a><br />

This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.

  </body>
</html>