

<!DOCTYPE html>

<html lang="fr">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Partie 4 | Dictionnaires: tables de hachages et autres implémentations &#8212; Documentation LINFO1121 2023-2024</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/translations.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Recherche" href="../search.html" />
 

  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Index général"
             accesskey="I">index</a></li>
        <li class="nav-item nav-item-0"><a href="../index.html">Documentation LINFO1121 2023-2024</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Partie 4 | Dictionnaires: tables de hachages et autres implémentations</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="partie-4-dictionnaires-tables-de-hachages-et-autres-implementations">
<span id="part4"></span><h1>Partie 4 | Dictionnaires: tables de hachages et autres implémentations<a class="headerlink" href="#partie-4-dictionnaires-tables-de-hachages-et-autres-implementations" title="Lien permanent vers ce titre">¶</a></h1>
<div class="section" id="objectifs">
<h2>Objectifs<a class="headerlink" href="#objectifs" title="Lien permanent vers ce titre">¶</a></h2>
<p>À l’issue de cette partie, chaque étudiant sera capable de:</p>
<ul class="simple">
<li><p>décrire avec exactitude et précision les concepts présents dans le chapitre du livre de référence, qui traite de tables de hachage</p></li>
<li><p>mettre en oeuvre des algorithmes basés sur les tables de hachage,</p></li>
<li><p>concevoir des fonctions de hachage adéquates pour différents types d’objets,</p></li>
<li><p>de résoudre des problèmes simples sur la mémorisation d’informations et leur accès dans des tables de hachage,</p></li>
<li><p>d’évaluer et mettre en oeuvre des représentations classiques de tables de hachage,</p></li>
<li><p>décrire et mettre en oeuvre avec précision l’algorithme de Rabin-Karp pour rechercher un texte dans un corpus.</p></li>
</ul>
</div>
<div class="section" id="a-lire">
<h2>A lire<a class="headerlink" href="#a-lire" title="Lien permanent vers ce titre">¶</a></h2>
<p>Livre de référence:</p>
<ul class="simple">
<li><p>chapitre 3.4, 3.5, 5.3 (Rabin-Karp fingerprint search only).</p></li>
</ul>
<p>Slides (keynote)</p>
<ul class="simple">
<li><p><a class="reference external" href="https://www.icloud.com/keynote/060axAx-WvIieFjqV9nvebAoQ#part4-intro">Introduction</a></p></li>
<li><p><a class="reference external" href="https://www.icloud.com/keynote/0TixMvOD8GNdrZKROHyYUiXfw#part4-bilan">Séance Intermédiaire</a></p></li>
<li><p><a class="reference external" href="https://www.icloud.com/keynote/0LwjcO8rozlr-a4jzmTvWMNww#part-4-bilan">Restructuration</a></p></li>
</ul>
</div>
<div class="section" id="exercices-theoriques-premiere-partie">
<h2>Exercices théoriques: première partie<a class="headerlink" href="#exercices-theoriques-premiere-partie" title="Lien permanent vers ce titre">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Vous devez faire ces exercices pour le mercredi de S9.</p>
</div>
<div class="section" id="exercice-4-1-1">
<h3>Exercice 4.1.1<a class="headerlink" href="#exercice-4-1-1" title="Lien permanent vers ce titre">¶</a></h3>
<p>Souvenez vous de la question suivante proposée en bilan sur la mission sur les tris: Étant donné un ensemble <span class="math notranslate nohighlight">\(S\)</span> de taille <span class="math notranslate nohighlight">\(n\)</span>, et un nombre <span class="math notranslate nohighlight">\(x\)</span>. Décrivez un algorithme efficace utilisant une HashTable pour trouver s’il existe une paire <span class="math notranslate nohighlight">\((a,b)\)</span> avec <span class="math notranslate nohighlight">\(a \in S,b \in S\)</span> telle que <span class="math notranslate nohighlight">\(a+b=x\)</span>. Quelle est la complexité de votre algorithme? Est-elle meilleure que votre solution qui utilisait un tri?</p>
</div>
<div class="section" id="exercice-4-1-2">
<h3>Exercice 4.1.2<a class="headerlink" href="#exercice-4-1-2" title="Lien permanent vers ce titre">¶</a></h3>
<p>Démontrez que <span class="math notranslate nohighlight">\((a + b) \% M\)</span> est équivalent à <span class="math notranslate nohighlight">\(((a \% M) + b) \% M\)</span>. En quoi cette propriété peut être utile pour construire une fonction de hachage sur les String.
Expliquez comment Java calcule une fonction de hachage sur les String?
Quelle est la complexité pour calculer 1 fois et <span class="math notranslate nohighlight">\(N\)</span> fois le hashcode d’un String.</p>
</div>
<div class="section" id="exercice-4-1-3">
<h3>Exercice 4.1.3<a class="headerlink" href="#exercice-4-1-3" title="Lien permanent vers ce titre">¶</a></h3>
<p>Expliquez pourquoi la méthode <cite>hash()</cite> p461 du livre retourne <cite>(x.hashCode() &amp; 0x7FFFFFFF) % M</cite> et pas simplement <cite>x.hashCode() % M</cite> ?
Quel nombre représente <cite>0x7FFFFFFF</cite> ?
Quelle est sa représentation binaire ?
Montrer l’impact au niveau binaire sur un exemple où <cite>x.hashCode()</cite> retourne un nombre négatif. Hint: utilisez <cite>Integer.toBinaryString(int)</cite> pour vérifier votre réponse.</p>
</div>
<div class="section" id="exercice-4-1-4">
<h3>Exercice 4.1.4<a class="headerlink" href="#exercice-4-1-4" title="Lien permanent vers ce titre">¶</a></h3>
<p>Java fournit la classe <cite>java.util.Hashtable</cite> comme implémentation de l’interface <cite>java.util.Map</cite>.
Pouvez-vous déterminer précisément de quelle variante de table de hachage il s’agit ?
Java fournit-il d’autres implémentations de l’interface <cite>Map</cite> ?
Faites un diagramme qui représente  les interfaces et les classes qui se rapportent à <cite>Map</cite> et précisez ce qui, dans chaque cas, les caractérise.
Qu’est-ce qui peut servir de clef pour une <cite>Hashtable</cite> en Java ? Soyez précis.</p>
</div>
<div class="section" id="exercice-4-1-5">
<h3>Exercice 4.1.5<a class="headerlink" href="#exercice-4-1-5" title="Lien permanent vers ce titre">¶</a></h3>
<p>Qu’entend-on par la notion de « collision » dans une table de hachage ?
Les collisions ont-elles une influence sur la complexité des opérations ?
Si oui, quelle(s) opération(s) avec quelle(s) complexité(s), sinon précisez pourquoi.</p>
</div>
<div class="section" id="exercice-4-1-6">
<h3>Exercice 4.1.6<a class="headerlink" href="#exercice-4-1-6" title="Lien permanent vers ce titre">¶</a></h3>
<p>Qu’est-ce que le facteur de charge d’une table de hachage.
Est-ce que le contrôle du facteur de charge est nécessaire/optionnel pour le bon fonctionnement d’une table de hachage avec Linear Probing ou Separate Chaining ?
Quelle est la stratégie utilisé par <cite>java.util.Hashtable</cite> pour contrôler le facteur de charge ?
En quoi est-elle différente de celle proposée dans`LinearProbinHashST` ?
Quel est le lien entre le facteur de charge et collision ?</p>
</div>
<div class="section" id="exercice-4-1-7">
<h3>Exercice 4.1.7<a class="headerlink" href="#exercice-4-1-7" title="Lien permanent vers ce titre">¶</a></h3>
<p>Imaginez une nouvelle méthode <cite>iterator()</cite> qui retourne un itérateur sur les clefs de <cite>LinearProbingHashST</cite>.
Votre itérateur ne devrait pas accepter de modification de la table de hashage alors qu’il est utilisé: une <cite>ConcurrentModificationException()</cite> doit être lancée si c’est le cas.
Que suggérez vous pour ce faire? Hint: Inspirez vous de la stratégie de <cite>java.util.Hashtable</cite>.</p>
</div>
<div class="section" id="exercice-4-1-8">
<h3>Exercice 4.1.8<a class="headerlink" href="#exercice-4-1-8" title="Lien permanent vers ce titre">¶</a></h3>
<p>Décrivez l’implémentation  de la méthode <cite>put(key)</cite> dans une table de hachage qui utilise la technique du « linear probing » pour gérer les collisions qui utiliserait un marqueur spécial pour représenter les entrées supprimées à l’aide de la méthode <cite>delete(key)</cite>.
En d’autres termes la méthode <cite>delete(key)</cite> au lieu de réarranger le contenu de la table de hachage de telle sorte qu’elle soit comme si l’entrée supprimée n’avait jamais été insérée, va simplement marquer l’entrée avec le marqueur spécial.
Quel est l’avantage ou l’inconvénient de cette approche par rapport à celle de « LinearProbingHashST » du livre ?</p>
</div>
<div class="section" id="exercice-4-1-9-rabin-karp">
<h3>Exercice 4.1.9 (Rabin-Karp)<a class="headerlink" href="#exercice-4-1-9-rabin-karp" title="Lien permanent vers ce titre">¶</a></h3>
<p>Imaginez une fonction de hachage pour un string <span class="math notranslate nohighlight">\(s\)</span> telle que connaître sa valeur pour le sous string <span class="math notranslate nohighlight">\(s[i,...,i+n-1]\)</span> permettrait de calculer la fonction de hachage du string <span class="math notranslate nohighlight">\(s[i+1,...,i+n]\)</span> en temps constant (de manière incrémentale).</p>
</div>
<div class="section" id="exercice-4-1-10-rabin-karp">
<h3>Exercice 4.1.10 (Rabin-Karp)<a class="headerlink" href="#exercice-4-1-10-rabin-karp" title="Lien permanent vers ce titre">¶</a></h3>
<p>Expliquez comment rechercher un sous string de taille <span class="math notranslate nohighlight">\(M\)</span> dans un long string de taille <span class="math notranslate nohighlight">\(N\)</span> en <span class="math notranslate nohighlight">\(O(N)\)</span> à l’aide d’une fonction de hachage incrémentale.
Comment feriez-vous si vous avez <span class="math notranslate nohighlight">\(k\)</span> strings de taille <span class="math notranslate nohighlight">\(M\)</span> à rechercher dans le long string de taille <span class="math notranslate nohighlight">\(N\)</span> ?
Quelle serait la complexité de votre méthode ? est-elle plus avantageuse que lancer k fois l’algorithme de Rabin-Karp ?</p>
</div>
</div>
<div class="section" id="exercices-d-implementation-sur-inginious">
<h2>Exercices d’implémentation sur Inginious<a class="headerlink" href="#exercices-d-implementation-sur-inginious" title="Lien permanent vers ce titre">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Vous devez faire ces exercices pour le mercredi de S10.</p>
</div>
<ol class="arabic simple">
<li><p><a class="reference external" href="https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part4QcmHashing">QCM fonction de hachage</a></p></li>
<li><p><a class="reference external" href="https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part4QcmRk">QCM Complexité RabinKarp</a></p></li>
<li><p><a class="reference external" href="https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part4IncrementalHash">Implem Fonction de Hash incémentale</a></p></li>
<li><p><a class="reference external" href="https://inginious.info.ucl.ac.be/course/LSINF1121-2016/Part4RabinKarp">Implem RabinKarp K patterns</a></p></li>
</ol>
</div>
<div class="section" id="exercices-theoriques-deuxieme-partie">
<h2>Exercices théoriques: deuxième partie<a class="headerlink" href="#exercices-theoriques-deuxieme-partie" title="Lien permanent vers ce titre">¶</a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Vous devez faire ces exercices pour le mercredi de S10.</p>
</div>
<div class="section" id="exercice-4-2-1-hash-des-long-and-double">
<h3>Exercice 4.2.1 (Hash des Long and Double)<a class="headerlink" href="#exercice-4-2-1-hash-des-long-and-double" title="Lien permanent vers ce titre">¶</a></h3>
<p>Voici la formule utilisée par Java pour calculer une fonction de hachage
sur les doubles (bits est un tableau de 64 bit représenté sous forme de long):
<cite>return (int) bits ^ (bits &gt;&gt;&gt; 32)</cite></p>
<ul class="simple">
<li><p>Pourquoi ne pas simplement utiliser <cite>(int) bits</cite> (casting de long vers int) ? Indice: Le livre de référence suggère qu’une bonne fonction de hachage doit utiliser tous les bits pour son calcul. Pourquoi ?</p></li>
<li><p>Un double en Java est représenté en 64 bits sous la forme <span class="math notranslate nohighlight">\((-1)^s \times m \times 2^{(e - 1023)}\)</span>. Le premier bit <span class="math notranslate nohighlight">\(s\)</span> est le signe, les 11 bits suivants représentent l’exposant sous forme binaire et les 52 derniers bits représentent la mantisse (partie décimale) sous forme binaire.  Est-ce qu’un nombre décimal positif et son opposé obtiennent des fonctions de hachage différentes ?</p></li>
</ul>
</div>
<div class="section" id="exercice-4-2-2-hash-des-int-castes">
<h3>Exercice 4.2.2 (Hash des int castés)<a class="headerlink" href="#exercice-4-2-2-hash-des-int-castes" title="Lien permanent vers ce titre">¶</a></h3>
<ul class="simple">
<li><p>Est-ce que la fonction de hachage d’un entier sur 32 bits et celle de ce même entier qui serait casté en double sont les mêmes ?</p></li>
<li><p>Est-ce que la fonction de hachage d’un entier sur 32 bits et celle de ce même entier qui serait casté en long sont les mêmes ?  Hint: <cite>Long.toBinaryString( Double.doubleToRawLongBits(a))</cite> permet d’afficher le tableau de bits utilisé pour la représentation d’un double.</p></li>
</ul>
</div>
<div class="section" id="exercice-4-2-3-hash-de-string-le-choix-de-m-et-r">
<h3>Exercice 4.2.3 (Hash de String: le choix de M et R)<a class="headerlink" href="#exercice-4-2-3-hash-de-string-le-choix-de-m-et-r" title="Lien permanent vers ce titre">¶</a></h3>
<p>La fonction de hachage pour un string donné tel que présenté dans le livre p460 est la suivante:</p>
<div class="highlight-java notranslate"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span></span>     <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
     <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="na">length</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
             <span class="n">hash</span> <span class="o">=</span> <span class="p">(</span><span class="n">R</span> <span class="o">*</span> <span class="n">hash</span> <span class="o">+</span> <span class="n">s</span><span class="p">.</span><span class="na">charAt</span><span class="p">(</span><span class="n">i</span><span class="p">))</span> <span class="o">%</span> <span class="n">M</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>Dans l’implémentation du livre, la taille de <span class="math notranslate nohighlight">\(M\)</span> (le tableau) est une puissance de deux.
La valeur suggérée pour <span class="math notranslate nohighlight">\(R\)</span> est <em>un petit nombre premier tel que 31 de sorte que les bits de tous les caractères jouent un rôle.</em></p>
<ul class="simple">
<li><p>Supposons que <span class="math notranslate nohighlight">\(R\)</span> soit un multiple de <span class="math notranslate nohighlight">\(M\)</span>. Que se passerait-il lors du calcul ?</p></li>
<li><p>Supposons que <span class="math notranslate nohighlight">\(R\)</span> est un nombre pair. Que se passerait-il ?</p></li>
<li><p>Dans les deux cas, combien d’entrées du string détermineront effectivement le code de hachage ? Quels sont les risques en termes de collision? Est-ce que le contrôle du facteur de charge peut résoudre le problème ? Expliquez pourquoi utiliser 31 est un choix judicieux pour des tailles de tableau qui sont des puissances de deux ? Serait-ce aussi un bon choix pour une taille de tableau qui commencerait à 31 et qui serait multipliée par deux à chaque fois qu’il faut redimensionner ?</p></li>
<li><p>Dans l’implémentation du livre la taille de M (le tableau) est une puissance de deux initialisée à 16. Supposons qu’à moment donné la taille de <span class="math notranslate nohighlight">\(M\)</span> soit <span class="math notranslate nohighlight">\(2^8=256\)</span>. Ensuite deux clefs entières sont ajoutées dans une table de hachage implémentée avec separate chaining: respectivement <span class="math notranslate nohighlight">\(2560\)</span> et <span class="math notranslate nohighlight">\(3072\)</span> (on suppose que ces ajouts ne causent pas de redimensionnement de la table). Comme vous le savez, le code de hachage d’une clef entière (int) est le nombre lui-même.</p></li>
</ul>
<p>Est-ce que l’ajout de ces deux valeurs va causer une collision entre elles dans la table ? Si oui pourquoi ?
Si oui pouvez-vous proposer une troisième valeur qui va aussi entrer en collision ?
Si collision il y a, peut-elle disparaître lors du prochain redimensionnement du tableau telle que dans l’implémentation du livre ?
* Que suggérez-vous pour éviter ce problème ? Quelle a la politique d’initialisation de <span class="math notranslate nohighlight">\(M\)</span> et de redimensionnement utilisée dans <cite>java.util.HashMap</cite> ? Est-ce que cela résout le problème sur notre exemple ?</p>
</div>
<div class="section" id="exercice-4-2-4-creation-de-hash-vehicules">
<h3>Exercice 4.2.4 (Création de Hash: Véhicules)<a class="headerlink" href="#exercice-4-2-4-creation-de-hash-vehicules" title="Lien permanent vers ce titre">¶</a></h3>
<ul class="simple">
<li><p>Que suggèreriez-vous comme fonction de hachage pour l’identification de véhicules qui sont des strings de nombres et de lettres de la forme: « 9X9XX99X9XX999999 » où un 9 représente un chiffre et un « X » une lettre de A à Z.</p></li>
<li><p>Est-ce que votre fonction de hachage a la propriété que pour une taille de tableau N hypothétique de <span class="math notranslate nohighlight">\(10^{11} \cdot 26^6\)</span> je n’ai jamais de collision</p></li>
</ul>
</div>
<div class="section" id="exercice-4-2-5-creation-de-hash-citoyens">
<h3>Exercice 4.2.5 (Création de Hash: Citoyens)<a class="headerlink" href="#exercice-4-2-5-creation-de-hash-citoyens" title="Lien permanent vers ce titre">¶</a></h3>
<p>Imaginons que l’on cherche à construire un répertoire des citoyens belges
et que l’on veuille pouvoir accéder à chaque citoyen par son numéro de carte d’identité
(12 chiffres).
On peut donc considérer ce numéro comme la clé unique identifiant
chaque citoyen et utiliser cette clé comme l’indice dans un tableau (array en Java).
A chaque indice correspondrait une référence vers une instance de la classe
<cite>Citoyen</cite> dont les champs constituent les informations que l’on désire mémoriser pour chacun.
Quelle est la complexité temporelle des opérations suivantes ?</p>
<ul class="simple">
<li><p>rechercher les informations relatives à un citoyen à partir de son numéro de carte
d’identité.</p></li>
<li><p>ajouter un nouveau citoyen.</p></li>
</ul>
<p>Cette implémentation d’un dictionnaire n’est-elle pas encore meilleure qu’une table de hachage ?
Peut-on avoir un problème de collision dans ce cas ? Justifiez.</p>
</div>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table des matières</a></h3>
  <ul>
<li><a class="reference internal" href="#">Partie 4 | Dictionnaires: tables de hachages et autres implémentations</a><ul>
<li><a class="reference internal" href="#objectifs">Objectifs</a></li>
<li><a class="reference internal" href="#a-lire">A lire</a></li>
<li><a class="reference internal" href="#exercices-theoriques-premiere-partie">Exercices théoriques: première partie</a><ul>
<li><a class="reference internal" href="#exercice-4-1-1">Exercice 4.1.1</a></li>
<li><a class="reference internal" href="#exercice-4-1-2">Exercice 4.1.2</a></li>
<li><a class="reference internal" href="#exercice-4-1-3">Exercice 4.1.3</a></li>
<li><a class="reference internal" href="#exercice-4-1-4">Exercice 4.1.4</a></li>
<li><a class="reference internal" href="#exercice-4-1-5">Exercice 4.1.5</a></li>
<li><a class="reference internal" href="#exercice-4-1-6">Exercice 4.1.6</a></li>
<li><a class="reference internal" href="#exercice-4-1-7">Exercice 4.1.7</a></li>
<li><a class="reference internal" href="#exercice-4-1-8">Exercice 4.1.8</a></li>
<li><a class="reference internal" href="#exercice-4-1-9-rabin-karp">Exercice 4.1.9 (Rabin-Karp)</a></li>
<li><a class="reference internal" href="#exercice-4-1-10-rabin-karp">Exercice 4.1.10 (Rabin-Karp)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#exercices-d-implementation-sur-inginious">Exercices d’implémentation sur Inginious</a></li>
<li><a class="reference internal" href="#exercices-theoriques-deuxieme-partie">Exercices théoriques: deuxième partie</a><ul>
<li><a class="reference internal" href="#exercice-4-2-1-hash-des-long-and-double">Exercice 4.2.1 (Hash des Long and Double)</a></li>
<li><a class="reference internal" href="#exercice-4-2-2-hash-des-int-castes">Exercice 4.2.2 (Hash des int castés)</a></li>
<li><a class="reference internal" href="#exercice-4-2-3-hash-de-string-le-choix-de-m-et-r">Exercice 4.2.3 (Hash de String: le choix de M et R)</a></li>
<li><a class="reference internal" href="#exercice-4-2-4-creation-de-hash-vehicules">Exercice 4.2.4 (Création de Hash: Véhicules)</a></li>
<li><a class="reference internal" href="#exercice-4-2-5-creation-de-hash-citoyens">Exercice 4.2.5 (Création de Hash: Citoyens)</a></li>
</ul>
</li>
</ul>
</li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Recherche rapide</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="Index général"
             >index</a></li>
        <li class="nav-item nav-item-0"><a href="../index.html">Documentation LINFO1121 2023-2024</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Partie 4 | Dictionnaires: tables de hachages et autres implémentations</a></li> 
      </ul>
    </div>

    <div class="footer" role="contentinfo">
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.3.1.
    </div>
<a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">
    <img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-sa/4.0/88x31.png" />
</a><br />

This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/4.0/">Creative Commons Attribution-ShareAlike 4.0 International License</a>.

  </body>
</html>